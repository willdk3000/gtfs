"use strict";require("core-js/modules/es6.promise");require("regenerator-runtime/runtime");function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _next(value) {step("next", value);}function _throw(err) {step("throw", err);}_next();});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var invariant = require('invariant');var _require =
require('lodash'),get = _require.get;

function tableDoesNotExist(err, table) {
  return (
    err.code === 'ER_NO_SUCH_TABLE' ||
    new RegExp(`relation "${table}" does not exist`).test(err.message) ||
    new RegExp(`no such table: ${table}`).test(err.message));

}

module.exports = function () {
  function KnexStorage(options) {_classCallCheck(this, KnexStorage);
    this.knex = options.connection;
    this.tableName = get(
    this.knex,
    'client.config.migrations.tableName',
    'knex_migrations');

    invariant(
    this.knex,
    "The option 'options.storageOptions.connection' is required.");

  }_createClass(KnexStorage, [{ key: "ensureTable", value: function ensureTable()

    {var _this = this;
      return this.knex(this.tableName).
      count('id').
      catch(function (err) {
        if (tableDoesNotExist(err, _this.tableName)) {
          return _this.knex.schema.createTable(_this.tableName, function (table) {
            table.increments();
            table.string('name');
            table.integer('batch');
            table.dateTime('migration_time');
          });
        }

        throw err;
      });
    } }, { key: "logMigration", value: function () {var _logMigration = _asyncToGenerator(regeneratorRuntime.mark(function _callee(

      migrationName) {var currentBatch;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                if (typeof this.currentBatch === 'undefined') {
                  this.currentBatch = this.getCurrentBatch();
                }_context.next = 3;return (

                  this.currentBatch);case 3:currentBatch = _context.sent;return _context.abrupt("return",

                this.knex(this.tableName).insert({
                  name: migrationName,
                  batch: currentBatch + 1,
                  migration_time: new Date() }));case 5:case "end":return _context.stop();}}}, _callee, this);}));return function logMigration(_x) {return _logMigration.apply(this, arguments);};}() }, { key: "unlogMigration", value: function unlogMigration(



    migrationName) {
      return this.knex(this.tableName).
      where('name', migrationName).
      del();
    } }, { key: "migrations", value: function migrations()

    {
      return this.knex(this.tableName).
      select().
      orderBy('id', 'asc');
    } }, { key: "executed", value: function executed()

    {var _this2 = this;
      return this.knex(this.tableName).
      orderBy('id', 'asc').
      pluck('name').
      catch(function (err) {
        if (tableDoesNotExist(err, _this2.tableName)) {
          return [];
        }

        throw err;
      });
    } }, { key: "getCurrentBatch", value: function getCurrentBatch()

    {
      return this.knex(this.tableName).
      max('batch as max_batch').
      then(function (obj) {return obj[0].max_batch || 0;});
    } }]);return KnexStorage;}();